module wave_capture
    #(
        DATA_WIDTH = 8 : DATA_WIDTH>0,
        CAPTURE_DEPTH = 256 : CAPTURE_DEPTH>0,
        BASE_ADDR = 32hfffffff0 : BASE_ADDR<=32hfffffff0,
        NONCE = 0 : NONCE.WIDTH<=32
    )
    (
        input clk,
        input rst,
        input<Register.master> regIn,
        output<Register.slave> regOut,
        input data[DATA_WIDTH]
    )
    {
        const VERSION = 32d2;
        
        const SUB_SECTIONS = $cdiv(DATA_WIDTH,32);
        
        .clk(clk) {
            .rst(rst) {
                fsm state = {IDLE,ARMED,FIRED,CAPTURED};
            }
            dff raddr[$clog2(CAPTURE_DEPTH)];
            dff waddr[$clog2(CAPTURE_DEPTH)];
            dff data_old[DATA_WIDTH];
            dff trigger_type[DATA_WIDTH][4];
            dff trigger_index[$clog2(DATA_WIDTH)];
            dff sub_idx[SUB_SECTIONS>1 ? $clog2(SUB_SECTIONS) : 1];
        }
        
        simple_dual_ram ram(#SIZE(DATA_WIDTH), #DEPTH(CAPTURE_DEPTH), .rclk(clk), .wclk(clk));
        
        var i;
        
        sig triggered;
        
        always {
            ram.waddr = waddr.q;
            ram.raddr = raddr.q;
            ram.write_data = data;
            ram.write_en = 0;
            regOut.data = 32bx;
            regOut.drdy = 0;
            data_old.d = data;
            case (state.q) {
                state.ARMED: 
                    triggered = 1;
                    for (i = 0;i<DATA_WIDTH; i++) {
                        triggered = triggered&((trigger_type.q[i][0]&&data_old.q[i]==0&&data[i]==1)||(trigger_type.q[i][1]&&data_old.q[i]==1&&data[i]==0)||(trigger_type.q[i][2]&&data[i]==0)||(trigger_type.q[i][3]&&data[i]==1)||trigger_type.q[i]==4b0);
                    }
                    if (triggered) {
                        ram.write_en = 1;
                        state.d = state.FIRED;
                        waddr.d = waddr.q+1;
                    }
                state.FIRED: 
                    waddr.d = waddr.q+1;
                    ram.write_en = 1;
                    if (waddr.q==CAPTURE_DEPTH-1) {
                        state.d = state.CAPTURED;
                    }
            }
            if (regIn.new_cmd) {
                if (regIn.write) {
                    case (regIn.address) {
                        BASE_ADDR: 
                            if (regIn.data==32h1) {
                                state.d = state.ARMED;
                                waddr.d = 0;
                                raddr.d = 0;
                            } else {
                                if (regIn.data==32h2) {
                                    state.d = state.FIRED;
                                    waddr.d = 0;
                                    raddr.d = 0;
                                }
                            }
                        BASE_ADDR+4: 
                            trigger_index.d = regIn.data[0+:trigger_index.WIDTH];
                        BASE_ADDR+5: 
                            trigger_type.d[trigger_index.q] = regIn.data[3:0];
                    }
                } else {
                    regOut.drdy = 1;
                    case (regIn.address) {
                        BASE_ADDR: 
                            regOut.data = c{ raddr.q==CAPTURE_DEPTH,state.q==state.CAPTURED,state.q==state.FIRED,state.q==state.ARMED };
                        BASE_ADDR+1: 
                            if (SUB_SECTIONS>1) {
                                regOut.data = ram.read_data[sub_idx.q*32+:32];
                                sub_idx.d = sub_idx.q+1;
                                if (sub_idx.q==SUB_SECTIONS-1) {
                                    sub_idx.d = 0;
                                    raddr.d = raddr.q+1;
                                }
                            } else {
                                regOut.data = ram.read_data;
                                raddr.d = raddr.q+1;
                            }
                        BASE_ADDR+2: 
                            regOut.data = DATA_WIDTH;
                        BASE_ADDR+3: 
                            regOut.data = CAPTURE_DEPTH;
                        BASE_ADDR+4: 
                            regOut.data = trigger_index.q;
                        BASE_ADDR+5: 
                            regOut.data = trigger_type.q[trigger_index.q];
                        BASE_ADDR+14: 
                            regOut.data = NONCE;
                        BASE_ADDR+15: 
                            regOut.data = VERSION;
                        default: 
                            regOut.drdy = 0;
                    }
                }
            }
        }
    }
